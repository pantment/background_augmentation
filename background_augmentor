import os
import cv2
import glob
import random
import numpy as np
import torch
from typing import Optional, Tuple
from torchvision import transforms
from utils import create_background_augmentor
import albumentations as A


class BatchAugmentor:
    def __init__(self, augmentation_type: str, background_transformations=None, object_transformations=None,
                 annotation_format: Optional[str] = None, interpolation: int = cv2.INTER_LINEAR,
                 enable_size_variance: bool = False, background_dir: Optional[str] = None,
                 mean: Tuple[float, float, float] = (0.485, 0.456, 0.406), std: Tuple[float, float, float] = (0.229, 0.224, 0.225)):
        """
        Initialize the BatchAugmentor.

        Args:
            augmentation_type (str): The type of augmentation ('semantic_segmentation' or 'object_detection').
            background_transformations (list): A list of albumentations to apply to the background.
            object_transformations (list): A list of albumentations to apply to the object.
            annotation_format (str): The format of the labels.
            interpolation (int): Interpolation method for resizing.
            enable_size_variance (bool): Whether to enable size variance during resizing.
            background_dir (str, optional): Directory path containing background images.
            mean (Tuple[float, float, float]): Mean for normalization.
            std (Tuple[float, float, float]): Standard deviation for normalization.
        """
        self.augmentation_type = augmentation_type
        self.augmentor = create_background_augmentor(augmentation_type, background_transformations, object_transformations,
                                                     annotation_format, interpolation, enable_size_variance)
        self.mean = mean
        self.std = std
        
        # Load background images from directory if provided
        self.background_images = self._load_background_images(background_dir) if background_dir else []

    def _load_background_images(self, background_dir: str) -> list:
        """
        Load all background images from the specified directory.

        Args:
            background_dir (str): Directory path containing background images.

        Returns:
            list: List of background images loaded as numpy arrays.
        """
        image_paths = glob.glob(os.path.join(background_dir, "*.*"))
        background_images = [cv2.imread(img_path) for img_path in image_paths if cv2.imread(img_path) is not None]
        return background_images

    def _get_random_background(self) -> np.ndarray:
        """
        Select a random background image from the loaded background images.

        Returns:
            np.ndarray: Randomly selected background image.
        """
        if not self.background_images:
            raise ValueError("No background images are loaded. Make sure the background directory contains valid images.")
        return random.choice(self.background_images)

    def _tensor_to_numpy(self, tensor: torch.Tensor) -> np.ndarray:
        """
        Convert a normalized PyTorch tensor to a NumPy array.

        Args:
            tensor (torch.Tensor): Normalized tensor to convert.

        Returns:
            np.ndarray: Denormalized image in NumPy format.
        """
        tensor = tensor.mul_(self.std).add_(self.mean)  # Denormalize
        tensor = tensor.permute(1, 2, 0).cpu().numpy()  # Convert to HWC format
        tensor = (tensor * 255).astype(np.uint8)  # Scale to [0, 255]
        return tensor

    def _numpy_to_tensor(self, array: np.ndarray) -> torch.Tensor:
        """
        Convert a NumPy array to a normalized PyTorch tensor.

        Args:
            array (np.ndarray): Image in NumPy format.

        Returns:
            torch.Tensor: Normalized tensor.
        """
        tensor = transforms.ToTensor()(array)  # Convert to tensor and scale to [0, 1]
        tensor = transforms.Normalize(self.mean, self.std)(tensor)  # Normalize
        return tensor

    def augment_batch(self, batch_images: torch.Tensor, batch_masks: torch.Tensor, batch_annotations: Optional[list] = None) -> Tuple[torch.Tensor, Optional[list]]:
        """
        Apply augmentations to a batch of images.

        Args:
            batch_images (torch.Tensor): Batch of images as tensors (normalized).
            batch_masks (torch.Tensor): Batch of masks as tensors.
            batch_annotations (list, optional): List of annotations for object detection.

        Returns:
            Tuple containing the augmented images and optionally the augmented annotations.
        """
        augmented_images = []
        augmented_annotations = [] if batch_annotations is not None else None

        batch_masks_np = batch_masks.cpu().numpy()

        for i in range(len(batch_images)):

            # Skip some images randomly
            if random.random() < 0.5:
                augmented_images.append(batch_images[i])
                augmented_annotations.append(batch_annotations[i] if batch_annotations is not None else None)

                continue
            # Convert tensors to numpy
            src_img = self._tensor_to_numpy(batch_images[i])
            src_mask = batch_masks_np[i]
            src_annotation = batch_annotations[i] if batch_annotations is not None else None

            # Get a random background for the current image
            src_background = self._get_random_background()


            augmented_image, augmented_annotation = self.augmentor.apply_augmentation(src_img, src_mask, src_background, src_annotation)
            augmented_images.append(self._numpy_to_tensor(augmented_image))
            augmented_annotations.append(torch.tensor(augmented_annotation))

        # Stack the augmented images back into a tensor
        augmented_images_tensor = torch.stack(augmented_images)
        augmented_annotations_tensor = torch.stack(augmented_annotations)


        return augmented_images_tensor, augmented_annotations_tensor

# Example usage
if __name__ == "__main__":
    # Define the transformations using albumentations
    background_transforms = [A.RandomBrightnessContrast(), A.GaussianBlur()]
    object_transforms = [A.HorizontalFlip(), A.VerticalFlip()]

    # Create the batch augmentor for semantic segmentation
    batch_augmentor = BatchAugmentor(
        augmentation_type="semantic_segmentation",
        background_transformations=background_transforms,
        object_transformations=object_transforms,
        background_dir="./background_images"
    )
    # batch of images and masks 
    sample_images = torch.rand(2, 3, 256, 256)
    sample_masks = torch.randint(0, 2, (2, 256, 256))

    # Augment the batch
    augmented_images, augmented_annotations = batch_augmentor.augment_batch(sample_images, sample_masks)

    # Display results
    for i, augmented_image in enumerate(augmented_images):
        cv2.imshow(f"Augmented Image {i}", augmented_image)
        cv2.waitKey(0)
    cv2.destroyAllWindows()